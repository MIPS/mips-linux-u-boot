#!/usr/bin/env python3
#
# SPDX-License-Identifier:	GPL-2.0+
#

import argparse
from enum import Enum

def bswap32(x):
    return int.from_bytes(x.to_bytes(4, byteorder='little'), byteorder='big', signed=False)

def sign_ext32(x):
    if x & 0x80000000:
        return x | 0xffffffff00000000
    return x

def hex_int(x):
    return int(x, 16)

parser = argparse.ArgumentParser(description="Generate a U-Boot fat binary")
parser.add_argument("-o", dest="outfile", default="u-boot.bin")
parser.add_argument("-b", dest="base", type=hex_int, default=0x9fc00000)
parser.add_argument("elfs", metavar="ELFs", nargs='+', help="U-Boot ELF files")
args = parser.parse_args()

if args.base & 0xffff:
    raise Exception("Flash base address must be 64KiB aligned")

if args.base == args.base & 0xffffffff:
    args.base = sign_ext32(args.base)

class Endianness(Enum):
    big = 0
    little = 1

class ELFFile:
    def __init__(self, stream):
        self.stream = stream

        self.stream.seek(0)
        magic = self.stream.read(4)
        if magic != b"\x7fELF":
            raise Exception("Not an ELF")

        ei_class = self.stream.read(1)
        if ei_class == b"\x01":
            self.bits = 32
        elif ei_class == b"\x02":
            self.bits = 64
        else:
            raise Exception("Unknown ELF class")

        ei_data = self.stream.read(1)
        if ei_data == b"\x01":
            self.endianness = Endianness.little
            self.end_str = "little"
        elif ei_data == b"\x02":
            self.endianness = Endianness.big
            self.end_str = "big"
        else:
            raise Exception ("Unknown ELF data")

        self.stream.seek(0x12)
        mach = int.from_bytes(self.stream.read(2), byteorder=self.end_str, signed=False)
        if mach != 0x08:
            raise Exception("Not a MIPS ELF file")

        self.stream.seek(0x24 if self.bits == 32 else 0x30)
        self.flags = int.from_bytes(self.stream.read(4), byteorder=self.end_str, signed=False)

    class ELFSegment:
        def __init__(self, fl, hdr):
            self.fl = fl

            self.type = int.from_bytes(hdr[0:4], byteorder=fl.end_str, signed=False)

            if self.fl.bits == 32:
                self.offset = int.from_bytes(hdr[4:8], byteorder=fl.end_str, signed=False)
                self.vaddr = int.from_bytes(hdr[8:12], byteorder=fl.end_str, signed=False)
                self.filesz = int.from_bytes(hdr[16:20], byteorder=fl.end_str, signed=False)
                self.memsz = int.from_bytes(hdr[20:24], byteorder=fl.end_str, signed=False)

                self.vaddr = sign_ext32(self.vaddr)
            else:
                self.offset = int.from_bytes(hdr[8:16], byteorder=fl.end_str, signed=False)
                self.vaddr = int.from_bytes(hdr[16:24], byteorder=fl.end_str, signed=False)
                self.filesz = int.from_bytes(hdr[32:40], byteorder=fl.end_str, signed=False)
                self.memsz = int.from_bytes(hdr[40:48], byteorder=fl.end_str, signed=False)

        def data(self):
            self.fl.stream.seek(self.offset)
            return self.fl.stream.read(self.filesz)

    def segments(self):
        segs = []

        self.stream.seek(0x1c if self.bits == 32 else 0x20)
        phoff = int.from_bytes(self.stream.read(self.bits // 8), byteorder=self.end_str, signed=False)

        self.stream.seek(0x2a if self.bits == 32 else 0x36)
        phentsize = int.from_bytes(self.stream.read(2), byteorder=self.end_str, signed=False)
        phnum = int.from_bytes(self.stream.read(2), byteorder=self.end_str, signed=False)

        for i in range(0, phnum):
            self.stream.seek(phoff + (i * phentsize))
            hdr = self.stream.read(phentsize)
            segs.append(ELFFile.ELFSegment(self, hdr))

        return segs

class Build:
    class LoadData:
        def __init__(self, seg):
            self.base = seg.vaddr
            self.data = seg.data()

    def __init__(self, filename, elf):
        self.filename = filename
        self.bits = elf.bits
        self.endianness = elf.endianness

        arch = elf.flags >> 28
        if arch in [ 7, 8 ]:
            self.arch_rev = 2
        elif arch in [ 9, 10 ]:
            self.arch_rev = 6
        else:
            raise Exception("Unknown architecture revision 0x%x" % arch)

        self.micromips = False

        self.data = []
        for seg in elf.segments():
            if seg.type == 0x1:
                self.data.append(Build.LoadData(seg))

    def base_addr(self):
        if len(self.data) == 0:
            return 0

        addr = self.data[0].base
        for data in self.data[1:]:
            if data.base < addr:
                addr = data.base

        return addr

    def overlaps(self, others):
        for oth in others:
            for oth_data in oth.data:
                oth_base = oth_data.base
                oth_end = oth_base + len(oth_data.data)

                for self_data in self.data:
                    self_base = self_data.base
                    self_end = self_base + len(self_data.data)

                    if self_base >= oth_base and self_base < oth_end:
                        return True
                    if self_end >= oth_base and self_end < oth_end:
                        return True

        return False

    def pretty_name(self):
        return "%ur%u%s" % (
                self.bits,
                self.arch_rev,
                "el" if self.endianness == Endianness.little else ""
        )

    def write(self, fl):
        for data in self.data:
            print("Write 0x%x-0x%x %s" % (data.base, data.base + len(data.data), self.filename))
            fl.seek(data.base - args.base)
            fl.write(data.data)

builds = []
for elf_filename in args.elfs:
    print(elf_filename)
    with open(elf_filename, "rb") as fl:
        build = Build(elf_filename, ELFFile(fl))
        if build.overlaps(builds):
            raise Exception("Builds Overlap")

        builds.append(build)

builds.sort(key=lambda build: build.base_addr())

any_micromips = sum(map(lambda build: 1 if build.micromips else 0, builds))

def gen_decode(vectors, off, endianness):
    vectors[off] = 0x08000000
    off += 1

vectors = [None for _ in range(0, 0x1000 // 4)]

for vec_off in [ 0x0, 0x200, 0x280, 0x300, 0x380, 0x400, 0x480 ]:
    off = vec_off // 4

    # Branch to .+0x44 if MIPS, nop if microMIPS
    mips_tgt = off + (0x44 // 4)
    vectors[off] = 0x10000010
    off += 1
    vectors[off] = 0x00000000
    off += 1

    if any_micromips:
        vectors[off] = 0xdeadbeef
        off += 1

    off = mips_tgt

    mips_decode = [
        0x401a8000,                                 # mfc0  k0, c0_config
        0x001ad282,                                 # srl   k0, k0, 10
        0x3c1b0000 | ((args.base >> 16) & 0xffff),  # lui   k1, %hi(base)
        0x7f5b3884,                                 # ins   k1, k0, 2, 6
        0x8f7a0100,                                 # lw    k0, 0x100(k1)
        0x275a0000 | (vec_off),                     # addiu k0, k0, vec_off
        0x03400009,                                 # jr    k0
        0x00000000,                                 #  nop
    ]

    vectors[off] = 0x04000010
    off += 1
    vectors[off] = 0x00000000
    off += 1

    vectors[off] = 0x10000000 + ((0x500 + vec_off) // 4) - off - 1
    off += 1
    vectors[off] = 0x00000000
    off += 1
    vectors[off] = 0x00000000
    off += 1

    # byte-swapped
    for insn in mips_decode:
        vectors[off] = bswap32(insn)
        off += 1

    # non-byte-swapped
    off = (0x500 + vec_off) // 4
    for insn in mips_decode:
        vectors[off] = insn
        off += 1

off = 0x100 // 4
for build in builds:
    if build.arch_rev == 1:
        ar = [ 0, 1]
    elif build.arch_rev == 2:
        ar = [ 1 ]
    elif build.arch_rev == 6:
        ar = [ 2 ]

    if build.bits == 32:
        at = [ 0, 1, 2 ]
    elif build.bits == 64:
        at = [ 1, 2 ]

    be = build.endianness == Endianness.big

    for _ar in ar:
        for _at in at:
            if be:
                addr = bswap32(build.base_addr() & 0xffffffff)
            else:
                addr = build.base_addr() & 0xffffffff

            vectors[off + _ar + (_at << 3) + (be << 5)] = addr

with open(args.outfile, 'wb') as fl:
    for insn in vectors:
        word = 0 if insn is None else insn
        fl.write(word.to_bytes(4, byteorder='little'))

    for build in builds:
        build.write(fl)
